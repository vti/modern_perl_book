=encoding utf8

=head1 Неявные идеи

Z<implicit_ideas>

Контекст это единственное лингвистическое сокращение в Perl. Программисты,
которые понимают эти сокращения могут с первого взгляда на код мгновенно понять
его наиболее важные характеристики. Другая важная лингвистическая особенность --
это Perl-эквивалент местоимения.

=head2 Скалярная переменная по умолчанию

Z<default_scalar_variable>

X<default variables; scalar>
X<default variables; C<$_>>
X<< variables; C<$_> >>
X<< C<$_>; default scalar variable >>

I<Скалярная переменная по умолчанию> (также называемая I<актуальная
переменная>), C<$_>, наиболее заметная при своём I<отсутствии>: многие
встроенные операторы Perl работают с содержимым C<$_> в случае отсутствия явной
переменной. Вы по-прежнему можете использовать C<$_> как переменную, но в этом
часто нет необходимости.

X<builtins; C<chomp>>
X<builtins; C<chr>>
X<builtins; C<ord>>
X<builtins; C<lc>>
X<builtins; C<length>>
X<builtins; C<reverse>>
X<builtins; C<uc>>

Многие скалярные операторы Perl (включая C<chr>, C<ord>, C<lc>, C<length>,
C<reverse>, и C<uc>) работают со скалярной переменной по умолчанию, если вы не
предоставили им альтернативы. Например, встроенная функция C<chomp> удалит
любую завершающую последовательность перевода строки своего операндаN<смотрите
C<perldoc -f chomp> и C<$/> для более точных деталей её поведения.>:

=begin programlisting

    my $uncle = "Стёпа\n";
    chomp $uncle;
    say "'$uncle'";

=end programlisting

C<$_> выполняет ту же функцию в Perl, что и местоимение I<это> в русском языке.
Без явной переменной, C<chomp> удалит завершающую последовательность перевода
строки в C<$_>. Perl понимает, что вы имели ввиду, когда сказали "C<chomp>";
Perl всегда "откусит" I<это>, поэтому эти две строки кода эквивалентны:

=begin programlisting

    chomp $_;
    chomp;

=end programlisting

X<builtins; C<say>>
X<builtins; C<print>>

Аналогично, C<say> и C<print> оперируют с C<$_> при отсутствии других
аргументов:

=begin programlisting

    print;  # напечатает $_ в текущий дескриптор файла
    say;    # напечатает "$_\n" в текущий дескриптор фала

=end programlisting

X<C<s///>; substitution operator>
X<C<m//>; match operator>
X<C<tr//>; transliteration operator>

Регулярные выражения в Perl (L<regex>) по умолчанию используют C<$_> для поиска
совпадений, замены и транслитерации:

=begin programlisting

    $_ = 'My name is Paquito';
    say if /My name is/;

    s/Paquito/Paquita/;

    tr/A-Z/a-z/;
    say;

=end programlisting

X<builtins; C<for>>

Директивы циклов в Perl (L<looping_directives>) по умолчанию используют C<$_>
как переменную итерации. Рассмотрим C<for>, проходящий по списку:

=begin programlisting

    say "#B<$_>" for 1 .. 10;

    for (1 .. 10)
    {
        say "#B<$_>";
    }

=end programlisting

X<builtins; C<while>>

... или C<while>:

=begin programlisting

    while (<STDIN>)
    {
        chomp;
        say scalar reverse;
    }

=end programlisting

X<builtins; C<map>>

... или C<map>, преобразующий список:

=begin programlisting

    my @squares = map { B<$_> * B<$_> } 1 .. 10;
    say for @squares;

=end programlisting

X<builtins; C<grep>>

... или C<grep>, фильтрующий список:

=begin programlisting

    say 'Время для завтрака!'
        if grep { /блинчики/ } @pantry;

=end programlisting

И обычная речь становится путанной, когда у вас слишком много местоимений
и антецедентов. Вы должны позаботиться об отсутствии одновременного явного
и неявного использования C<$_>. Непредусмотрительное одновременное
использование C<$_> может привести к тому, что одна часть кода молча
переписывает значение, записанное другой. Если вы пишите функцию, которая
использует C<$_>, вы можете разрушить, используемую вызывающей функцией,
переменную C<$_>.

Начиная с Perl 5.10, вы можете объявлять C<$_> как лексическую переменную
(L<lexical_scope>), чтобы избежать этого разрушительного поведения:

=begin programlisting

    while (<STDIN>)
    {
        chomp;

        # ПЛОХОЙ ПРИМЕР
        my $munged = calculate_value( $_ );
        say "Оригинальное: $_";
        say "Распознанное: $munged";
    }

=end programlisting

Если C<calculate_value()> или любая другая функция изменяет C<$_>, это изменение
сохранится в течении этой итерации цикла. Добавление объявления C<my>
предотвращает порчу существующего экземпляра C<$_>:

=begin programlisting

    while (my $_ = <STDIN>)
    {
        ...
    }

=end programlisting

Разумеется, использование именованной лексемы может быть столь же понятным:

=begin programlisting

    while (my $line = <STDIN>)
    {
        ...
    }

=end programlisting

Используйте C<$_> также как слово "это" в обычном письме: экономно, в небольших
и вполне определённых пределах.

=begin tip Оператор C<...>

X<builtins; C<...>>

В Perl 5.12 появился оператор тройной точки (C<...>) для обозначения кода,
который вы намереваетесь написать позже. Perl распознает его как обычный
оператор, но бросит исключение, когда вы попытаетесь запустить ещё
нереализованный код. Смотрите C<perldoc perlop> для деталей.

=end tip

=head2 Переменная массива по умолчанию

Z<default_array_variables>

X<default variables; array>
X<default variables; C<@_>>
X<variables; C<@_>>
X<C<@_>>

Perl также имеет две переменные неявных массивов. Perl передаёт аргументы
функциям (L<functions>) в массиве называемом C<@_>. Операции над массивом
(L<arrays>) внутри функций используют этот массив по умолчанию, поэтому эти два
примера кода эквивалентны:

=begin programlisting

    sub foo
    {
        my $arg = shift;
        ...
    }

    sub foo_explicit_args
    {
        my $arg = shift @_;
        ...
    }

=end programlisting

X<builtins; C<shift>>
X<builtins; C<pop>>

Также как C<$_> соответствует местоимению I<это>, так и C<@_> соответствует
местоимению I<эти>. В I<отличие> от C<$_>, Perl автоматически локализует C<@_>,
когда вы вызываете другие функции. Встроенные функции C<shift> и C<pop>
оперируют над C<@_>, если отсутствуют другие операнды.

X<default variables; C<@ARGV>>
X<variables; C<@ARGV>>
X<C<@ARGV>>

Вне всех функций переменная по умолчанию C<@ARGV> содержит аргументы командной
строки программы. Операции Perl над массивом (включая C<shift> и C<pop>)
работают и с C<@ARGV> явно вне функций. Вы не можете использовать C<@_>, если
имеете ввиду C<@ARGV>.

=begin tip C<readline>

X<builtins; C<readline>>
X<builtins; C<glob>>

Оператор Perl C<< <$fh> >> это тоже самое, что и встроенная функция C<readline>.
C<readline $fh> делает то же самое, что и C<< <$fh> >>. Начиная с Perl 5.10,
просто C<readline> ведёт себя также как и C<< <> >>, поэтому вы можете
использовать C<readline> везде. По историческим причинам, C<< <> >> по-прежнему
очень распространён, но подумайте об использовании C<readline> как о более
читабельной альтернативе. Вы, возможно, предпочтёте C<glob '*.html'> вместо C<<
<*.html> >>, правильно? Тут та же идея.

=end tip

X<null filehandle>

C<ARGV> имеет один специальный случай. Если вы читаете из нулевого файлового
дескриптора C<< <> >>, Perl будет рассматривать каждый элемент в C<@ARGV>, как
I<имя> файла для открытия на чтение. (Если C<@ARGV> пустой, Perl будет читать
со стандартного ввода.) Это неявное поведение C<@ARGV> полезно при написании
коротких программ, как этот фильтр командной строки, который переворачивает
данные, получаемые со входа:

=begin programlisting

    while (<>)
    {
        chomp;
        say scalar reverse;
    }

=end programlisting

Зачем нужен C<scalar>? C<say> подразумевает списочный контекст для своих
операндов. C<reverse> передаёт свой контекст своим операндам, рассматривая их
как список в списочном контексте и соединёнными строками в скалярном контексте.
Если поведение C<reverse> кажется вам странным, то ваши инстинкты вас не
подводят. Perl 5 действительно должен быть отдельный "reverse для строки"
и "reverse для списка".

Если вы запустите его со списком файлов:

=begin screen

    $ B<perl reverse_lines.pl encrypted/*.txt>

=end screen

... результатом будет один длинный поток вывода. Без аргументов вы можете
выдать свой собственный стандартный ввод, взяв его из вывода другой программы,
или непосредственно введя его. И всё же Perl хорош не только для маленьких
программ командной строки....
