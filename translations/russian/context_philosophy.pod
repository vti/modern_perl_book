=encoding utf8

=head1 Контекст

Z<context_philosophy>

X<context>

В разговорных языках значение слова или фразы может зависеть от того как
вы их используете; текущий I<контекст> помогает прояснить смысл. Например,
неподходящее использование множественного числа в "Пожалуйста, дайте мне один
гамбургеры!"N<Множественное число существительного отличается от количества.>
звучит неправильно, также как и неверный род в "милый кошка"N<прилагательное
мужского рода, но существительное женского рода.> вызовут улыбку у носителя
языка. Возьмите местоимение "вы" или существительное "метро", которые могут
быть в единственном или множественном числе в зависимости от контекста.

Контекст в Perl схож с контекстом в обычном языке. Он принимает во внимание как
количество, так и тип данных. Perl с радостью попытается сделать именно то, что
вы хотели -- при условии, что вы выбрали подходящий контекст.

Некоторые операции в Perl производят различные действия, если вы запрашиваете
ноль, один или несколько результатов. Специфичная конструкция в Perl может
делать что-то отличное в том случае, если вы напишите "Сделай это, но меня не
волнует результат", в сравнении с "Сделай это и я ожидаю получить несколько
результатов". Другие операции позволяют вам указать ожидаете ли вы работать
с численными данными, текстовыми данными или со значениями истина или ложь.

Контекст может показаться сложным, если вы пытаетесь писать или читать Perl код
как серию одиночных выражений, извлечённых из их окружения. И даже хлопнуть себя
по лбу после продолжительного времени отладки, когда вдруг обнаружите, что ваше
предположение о контексте было ошибочным. Если бы вместо этого вы были бы
осведомлены о контексте, ваш код стал бы правильнее -- и чище, и гибче,
и короче.

=head2 Пустой, Скалярный и Списочный Контекст

Z<amount_context>

X<context; amount>
X<amount context>

I<Количественный контекст> управляет тем I<как много> элементов вы ожидаете от
операции. Самым близким аналогом может выступить соотношение числа подлежащего
со сказуемым. Даже не зная формального определение этого лингвистического
принципа, вы вероятно видите ошибку в предложении "Perl являются прикольным
языком". В Perl число запрашиваемых элементов определяет количество полученных.

X<void context>
X<context; void>

Предположим, у вас есть функция (L<functions>) называемая C<find_chores()>,
которая сортирует ваш семейный список запланированных дел в порядке приоритета
задачи. Способ вызова этой функции, повлияет на ее поведение. У вас может не
быть времени сделать уборку, в этом случае вызов функции это просто попытка
выглядеть трудолюбивым. Возможно, у вас достаточно времени, чтобы сделать одно
дело или у вас прилив сил в свободный выходной и желание сделать как можно
больше.

Если вы вызываете функцию и не используете возвращаемый ею результат, то вы
вызываете функцию в I<пустом контексте>:

=begin programlisting

    find_chores();

=end programlisting

X<context; scalar>
X<scalar context>

Присвоение возвращаемого функцией значения одиночному элементу (L<scalars>),
вычисляет функцию в I<скалярном контексте>:

=begin programlisting

    my $single_result = find_chores();

=end programlisting

X<list context>
X<context; list>

Присвоение результатов вызова функции массиву (L<arrays>) или списку, или
использование его в списке, вычисляет функцию в I<списочном контексте>:

=begin programlisting

    my @all_results             = find_chores();
    my ($single_element, @rest) = find_chores();
    process_list_of_results( find_chores() );

=end programlisting

Скобки во второй строчке предыдущего примера группируют объявление двух
переменных (L<lexical_scope>) так, что присваивание произойдёт так, как вы того
ожидаете. Если бы C<@rest> не использовался, вы также совершенно правильно
написали бы:

=begin programlisting

    my B<(>$single_elementB<)>   = find_chores();

=end programlisting

... в таком случае скобки дают подсказку анализатору Perl 5, что вы имеете ввиду
списочный контекст для присваивания, даже если присваиваете только одному
элементу списка. Это тонкость, но вы теперь знаете о ней, и разница
в количественном контексте между этими двумя выражениями должна быть очевидна:

=begin programlisting

    my $scalar_context = find_chores();
    my B<(>$list_contextB<)> = find_chores();

=end programlisting

Вычисление функции или выражения -- за исключением присваивания -- в списочном
контексте может привести к путанице. Списки распространяют списочный контекст на
выражения, которые они содержат. Оба этих вызова C<find_chores()> происходят
в списочном контексте:

=begin programlisting

    process_list_of_results( find_chores() );

    my %results =
    (
        cheap_operation     => $cheap_results,
        expensive_operation => find_chores(), # ОЙ!
    );

=end programlisting

X<builtins; C<scalar>>

Последний пример часто удивляет новичков программистов, при инициализации хеша
(L<hashes>) со списком значений устанавливается списочный контекст на
C<find_chores>. Используйте оператор C<scalar>, чтобы навязать скалярный
контекст:

=begin programlisting

    my %results =
    (
        cheap_operation     => $cheap_results,
        expensive_operation => B<scalar> find_chores(),
    );

=end programlisting

Почему контекст имеет значение? Функции, понимающие контекст, могут проверять
в каком контексте они вызваны и решать какое количество работы им потребуется
выполнить. В пустом контексте C<find_chores()> может вполне законно ничего ни
делать. В скалярном контексте она может найти самую важную задачу. В списочном
контексте она должна отсортировать и вернуть весь список целиком.

=head2 Числовой, Строковый и Логический Контекст

Z<value_contexts>

X<value context>
X<context; value>

Другой контекст Perl -- I<контекст значения> -- определяет как Perl
интерпретирует данные. Вы уже, возможно, заметили, что Perl гибок в вопросе
определения число у нас или строка, и конвертирования из одного в другое, если
такое требуется. В обмен на отсутствие явного объявление (или по-крайне мере
отсутствие проверок) какой I<тип> данных содержится в переменной или выводе
функции, контекст типа в Perl даёт подсказки, которые говорят компилятору как
воспринимать данные.

X<builtins; C<eq>>

Perl приводит значения к определённому типу (L<coercion>), в зависимости от
того, какой оператор вы используете. Например, оператор C<eq> проверяет, что
строки содержат одинаковую информацию I<как строки>:

=begin programlisting

    say "Катастрофическая крипто ошибка!" if $alice eq $bob;

=end programlisting

У вас, возможно, есть проблемный опыт, когда вы I<знаете>, что строки разные, но
они по-прежнему оказываются равными:

=begin programlisting

    my $alice = 'Алиса';
    say "Катастрофическая крипто ошибка!" if $alice == 'Боб';

=end programlisting

X<string context>
X<numeric context>
X<context; string>
X<context; numeric>

X<builtins; C<==>>

Оператор C<eq> воспринимает свои операнды как строки, принудительно вводя
I<строковой контекст> для них. Оператор C<==> навязывает I<числовой контекст>.
В числовом контексте обе строки вычисляются в C<0> (L<numeric_coercion>).
Убедитесь, что используете правильный оператор для того типа контекста,
который вам нужен.

X<boolean context>
X<context; boolean>

I<Логический контекст> встречается, когда вы используете значение в условном
операторе. В предыдущем примере C<if> вычисляет результат операторов C<eq> и
C<==> в логическом контексте.

X<context; explicit>

В редких случаях вам может потребоваться принудительно установить контекст,
когда не существует подходящего для этих целей оператора. Чтобы установить
числовой контекст, прибавьте ноль к переменной. Для установки строкового
контекста, присоедините к переменной пустую строку. Чтобы установить
логический контекст, добавьте двойной оператор отрицания:

=begin programlisting

    my $numeric_x =  0 + $x;  # принудительный числовой контекст
    my $stringy_x = '' . $x;  # принудительный строковой контекст
    my $boolean_x =    !!$x;  # принудительный логический контекст

=end programlisting

Контекст типа определить значительно проще, чем количественный контекст. Как
только вы узнаете какой контекст дают различные операторы (L<operator_types>),
вы редко будете делать ошибки.
