=head1 Углубленное ОО в Perl

Z<advanced_oo>

Создание и использование объектов в Perl 5 с помощью Moose (L<moose>) это
просто. I<Проектирование> хороших программ -- нет. Вы должны балансировать между
слишком малым и слишком большим проектированием. Только практический опыт может
помочь вам понять наиболее важные техники проектирования, но несколько принципов
могут послужить ориентирами.

=head2 Отдавайте предпочтение композиции перед наследованием

X<OO: composition>
X<OO; inheritance>

Начинающее ОО проектирование обычно злоупотребляет наследованием для повторного
использования кода и эксплуатирует полиморфизм. Результатом является глубокая
иерархия классов с обязанностями разнесенными по неправильным местам. Поддержка
такого кода сложна -- кто знает где можно добавить или изменить поведение? Что
произойдет когда код в одном месте конфликтует с кодом объявленным где-то еще?

X<OO; is-a>
X<OO; has-a>

Наследование это один из инструментов. C<Car> может наследовать
C<Vehicle::Wheeled> (I<is-a отношение>), но C<Car>, возможно, стоит лучше
I<иметь> несколько C<Wheel> объектов в качестве атрибутов (I<has-a отношение>).

Декомпозиция сложных классов в небольшие, сфокусированные сущности (будь то
классы или роли) улучшает инкапсуляцию и уменьшает вероятность того, что
какой-то один класс или роль будет делать слишком много. Меньшие, простые
и инкапсулированные сущности легче понять, тестировать и сопровождать.

=head2 Принцип единственной обязанности

X<OO; single responsibility principle>

Когда вы проектируете свою объектную модель, подуймате об обязанностях каждой
сущности. Например, объект C<Employee> может представлять конкретную информацию
об имени, контактах, и других персональных данных сотрудника, в тоже время
объект C<Job> может предоставлять бизнес ответственность. Разделение этих
сущностей на уровне их ответственности позволяет классу C<Employee> заниматься
проблемами управления информации специфичной для личности сотрудника, а классу
C<Job> что сотрудник делает. (Два объекта C<Employee> могут иметь общий C<Job>
объект, например).

Когда у каждого класса единственная обязанность, вы улучшаете инкапсуляцию
специфичных для класса данных и поведения, и уменьшаете связанность между
классами.

=head2 Не повторяйте себя

X<DRY>

Сложность и дублирование затрудняют разработку и сопровождение. Принцип DRY
(Don't Repear Yourself, I<Не повторяйте себя> -- прим. перев.) служит
напоминанием, чтобыы искать и устранять дублирование в системе. Дублирование
существует как в коде, так и в данных. Вместо повторения конфигурационной
информации, пользовательских данных и других артефактов системы, создайте одно,
каноническое представление этой информации, из которой можно генерировать другие
артефакты.

Этот принцип позволяет уменьшить вероятность того, что важные части вашей
системы могут рассинхронизироваться, и помогает вам найти оптимальное
представление системы и ее данных.

=head2 Принцип подстановки Лисков

X<OO; Liskov Substitution Principle>

Принцип подстановки Лисков советует, что у вас должна быть возможность заменить
конкретизацию класса или роли на оригинальную без нарушения оригинального API.
Другими словам, объект должен быть как можно общим по отношении к тому, чего он
ожидает и как можно строгим по отношению к тому, что он производит.

Представьте два класса C<Dessert> и его дочерний класс C<PecanPie>. Если классы
следуют принципу подстановки Лисков, вы можете заменить использование объекта
C<Dessert> на объект C<PecanPiece> в тестовом наборе и тесты должны все так же
проходитьN<Посмотрите на "IS-STRICTLY-EQUIVALENT-TO-A" от Reg Braithwaite для
более подробных деталей,
U<http://weblog.raganwald.com/2008/04/is-strictly-equivalent-to.html>.>.

=head2 Подпипы и приведение типов

Z<subtypes>
Z<coercions>
X<types>
X<subtypes>
X<coercion>

Moose позволяет вам объявлять и использовать типы и расширять их через подтипы
для формирования еще более конкретных описаний того как представлены ваши данные
и как они себя ведут. Эти аннотации типов помогают убедиться, что данные, над
которыми вы хотите работать специальными функциями или методами, являются
соответствующими, и даже помогают описать механизмы которыми эти данные одного
типа приводятся к данным другого типа.

X<C<Moose::Util::TypeConstraints>>
X<C<MooseX::Types>>

Посмотрите на C<Moose::Util::TypeConstraints> и C<MooseX::Types> для большей
информации.

=head2 Неизменяемость

Z<immutability>

X<OO; immutability>

Новички в ОО обычно работают с объектами как если бы они были набором записей,
которые используют методы для установки и чтения внутренних значений. Этот
простой подходит приводит к неудачному желанию распространить обязанность этого
объекта по всей системе.

С хорошо спроектированным объектом вы говорите ему что делать, а не как делать.
Как правило, если вы замечаете, что обращаетесь к данным объекта (даже через
методы доступа), у вас, возможно, слишком много доступа ко внутренностям
объекта.

Одним подходом для предотвращения такого поведения является использование
неизменяемых объектов. Подготовьте необходимые данные для конструктора, затем
запретите любое изменение этой информации извне класса. Не предоставляйте методы
для изменения данных объекта. Объекты, созданные таким путем, всегда корректны
после их создания и не могут стать некорректными из-за манипуляций извне. Такое
достижение требует колоссальной дисциплины, но в результате системы получаются
надежными, тестируемыми и поддерживаемыми.

Некоторые подходы заходят так далеко, что запрещаеют изменять данные объекта
I<изнутри> класса тоже, хотя это гораздо сложнее.
