=head1 Bless-ссылки

Z<blessed_references>

Объектная модель Perl 5 намеренно минимальная. У нее есть три правила:

=over 4

=item * Класс это пакет.

=item * Метод это фунция.

=item * Ссылка (blessed) это объект.

=back

Вы можете построить что угодно из этих трех правил, но это все, что вы получаете
из коробки. Такой минимализм может быть не практичным для больших проектов --
в частности, возможности для более высоких абстракций через метапрограммирование
(L<code_generation>) неуклюжи и ограничены. Moose (L<moose>) лучший выбор для
современных программ длиннее нескольких сотен строк, хотя много устаревшего
кода до сих пор использует стандартную ОО модель Perl 5.

X<OO; C<bless>>
X<builtins; C<bless>>

Финальной частью ОО в Perl 5 является bless ссылка. Встроенная функция C<bless>
связывает имя класса со ссылкой. Это ссылка теперь полноценный инвокант, и Perl
будет производить разрешение методов, используя связанный класс.

X<OO; constructors>
X<OO; class methods>
X<methods; class>

Конструктор это метод, который создает ссылку и выполняет bless на ней. По
соглашению, конструкторы называются C<new()>, но это не обязательно.
Конструкторы это практически всегда C<методы класса>.

C<bless> принимает два параметра: ссылку и имя класса. Ссылка может быть пустой.
Класс не обязательно должен существовать. Можно даже использовать C<bless> и вне
конструктора или класса (хотя любой код, кроме совсем простых программ, должен
использовать настоящие конструкторы). Канонический конструктор выглядит так:

=begin programlisting

    sub new
    {
        my $class = shift;
        bless {}, $class;
    }

=end programlisting

Конструктор получает имя класса в качестве инвоканта. Вы можете также жестко
указать имя класса, впрочем засчет потери гибкости. Параметрический конструктор
обеспечивает повторное использование через наследование, делегацию и экспорт.

X<OO; instance data>

Тип ссылки имеет значение только для внутреннего хранения I<данных объекта>. Нет
никаких других эффектов влияющих на результирующий объект. Хеш-ссылки наиболее
распространены, но вы можете вызвать bless на любой ссылке:

=begin programlisting

    my $array_obj  = bless [], $class;
    my $scalar_obj = bless \$scalar, $class;
    my $sub_obj    = bless \&some_sub, $class;

=end programlisting

Moose классы объявляют атрибуты объекта декларативно, а встроенная же в Perl
5 ОО модель довольно неопределенная. Класс, который представляет игроков
в баскетбол и хранит номер и позицию, может иметь конструктор похожий на:

=begin programlisting

    package Player
    {
        sub new
        {
            my ($class, %attrs) = @_;
            bless \%attrs, $class;
        }
    }

=end programlisting

... и может создавать игроков:

=begin programlisting

    my $joel  = Player->new( number  => 10,
                            position => 'center' );

    my $dante = Player->new( number   => 33,
                             position => 'forward' );

=end programlisting

Методы класса могут обращаться к атрибутам объекта как к хеш-элементам напрямую:

=begin programlisting

    sub format
    {
        my $self = shift;
        return '#'       . $self->{number}
             . ' plays ' . $self->{position};
    }

=end programlisting

... но так может и любой другой код, следовательно изменение внутреннего
представления может сломать и его. Методы доступа безопаснее:

=begin programlisting

    sub number   { return shift->{number}   }
    sub position { return shift->{position} }

=end programlisting

... и теперь вы начинаете вручную реализовывать все то, что Moose и так
предоставляет. Более того, Moose поощряет использование методов доступа вместо
прямого доступа, скрывая реализацию таких методов. До свидания, искушение.

=head2 Поиск метода и наследование

X<method dispatch>
X<OO; methods>

Имея bless-ссылку, такой вызов метода:

=begin programlisting

    my $number = $joel->number();

=end programlisting

... ищет имя в классе связанным с bless-ссылкой C<$joel> -- в этом случае
C<Player>. Далее Perl ищет функциюN<Помните, что в Perl нет разницы между
функцией в области видимости и методом.> C<number()> в классе C<Player>. Если
такой функции не существует и если C<Player> наследует класс, Perl ищет
в родительском классе (и так далее) пока не находит C<number()>. Если Perl
находит C<number()>, он вызывает этот метод с C<$joel> в качестве инвоканта.

=begin tip Сохраняя область видимости чистой

X<CPAN; C<namespace::autoclean>>

CPAN модуль C<namespace::autoclean> может помочь избежать непреднамеренных
коллизий между импортируемыми функциями и методами.

=end tip

X<C<@ISA>>
X<OO; C<@ISA>>

Moose предоставляет ключевое слово C<extends> для наследования, но Perl
5 использует глобальную пакетную переменную C<@ISA>. При назначении методов идет
поиск в каждой переменной C<@ISA> в каждом классе для поиска его родителей.
Если C<InjuredPlayer> наследует C<Player>, вы можете написать:

=begin programlisting

    package InjuredPlayer
    {
        @InjuredPlayer::ISA = 'Player';
    }

=end programlisting

X<C<parent> pragma>
X<pragmas; C<parent>>

Прагма C<parent> (L<pragmas>) является предпочтительнейN<Старый код может
использовать прагму C<base>, но C<parent> заменил C<base> в Perl 5.10.>:

=begin programlisting

    package InjuredPlayer
    {
        use parent 'Player';
    }

=end programlisting

У Moose есть своя собственная метамодель, которая хранит информацию
о наследовании; это дает свои дополнительные преимущества.

X<multiple inheritance>
X<OO; inheritance>

Вы можете наследоваться от нескольких классов:

=begin programlisting

    package InjuredPlayer;
    {
        use parent qw( Player Hospital::Patient );
    }

=end programlisting

... хотя тут могут проявиться недостатки множественного наследования и сложности
поиска методов. Подуймайте об использовании ролей (L<roles>) или
модификаторов в Moose.

=head2 AUTOLOAD

X<C<AUTOLOAD>>
X<OO; C<AUTOLOAD>>
X<methods; C<AUTOLOAD>>

Если нужный метод не был найден в вызывающем классе или в его суперклассах, Perl
5 затем посмотрит на наличие функции C<AUTOLOAD()> (L<autoload>) в каждом классе
в соответствии с порядком принятым в текущем способе поиска методов. Perl вызовет
найденную функцию C<AUTOLOAD()>, которая реализует либо отклоняет метод.

C<AUTOLOAD()> делает множественное наследование еще более сложным для понимания.

=head2 Переопределение методов и SUPER

Как и в Moose вы можете переопределять методы и в стандартной ОО модели Perl 5.
В отличие от Moose, стандартная модель не предоставляет механизма для
обозначения вашего I<намерения> переопределить метод родительского класса. Еще
хуже то, что любая функция с таким же именем, которую вы объявите в дочернем
классе или импортируете туда, может переопределить метод в родительском классе.
Даже если вы забудете про C<override> в Moose, это хотя бы существует.
У стандратной ОО модели в Perl 5 нет такой защиты.

X<builtins; C<SUPER::>>

Для переопределения метода в дочернем классе, объявите метод с таким же именем,
что и в родительском. Внутри переопределенного метода вызовите родительский
метод с помощью C<SUPER::>.

=begin programlisting

    sub overridden
    {
        my $self = shift;
        warn 'Called overridden() in child!';
        return $self->SUPER::overridden( @_ );
    }

=end programlisting

Префикс C<SUPER::> перед именем метода означает вызов переопределенного метода
с соответствующим именем. Вы можете передать свои собственные аргументы
в переопределенный метод, но большинство кода использует C<@_>. Не забудьте
сделать C<shift>, чтобы достать вызывающий объект.

=begin tip Проблема c C<SUPER::>

X<CPAN; C<SUPER>>

У C<SUPER::> есть вводящий в заблуждение недостаток: он вызывает
переопределенный родительский метод пакета в котором он был I<скомпилирован>.
Если вы импортируете этот метод из другого пакета, Perl спокойно вызовет
I<неправильного> родителя. Из-за желания сохранить обратную совместимость, это
так и не было исправлено. Модуль C<SUPER> с CPAN предлагает обходное решение.
C<super()> в Moose не страдает такой проблемой.

=end tip

=head2 Способы совладания с bless-ссылками

Если bless-ссылки выглядят ограниченными, запутанными и вводящими в заблуждение,
то так оно и есть. Moose это колоссальное улучшение. Используйте эту библиотеку
когда возможно. Если вам приходится поддерживать код, который использует
bless-ссылки, или вы не можете убедить вашу команду использовать Moose, вы
можете обойти некоторые проблемы bless-ссылок самодисциплиной.

X<C<Class::Accessor>>

=over 4

=item * Используйте методы доступа повсеместно, даже внутри методов вашего
класса. Рассмотрите возможность использования такого модуля как
C<Class::Accessor> для избежания одинакового шаблонного кода.

=item * Избегайте C<AUTOLOAD()> везде где возможно. Если вам обязательно нужна
эта функция, используйте упреждающее объявление ваших функций (L<functions>)
чтобы помочь Perl узнать какой C<AUTOLOAD()> предоставляет нужные методы.

=item * Ожидайте того, что кто-то и где-то в конечном итоге захочет
унаследоваться (или делегировать, или реализовать интерфейс) от ваших классов.
Сделайте это простым, не раскрывая особенности внутренней реализации, используя
C<bless> с двумя параметрами и разнося классы на небольшие блоки кода.

=item * Не смешивайте функции и методы в одном и том же классе.

=item * Используйте отдельный F<.pm> файл для каждого класса, если только это не
небольшой вспомогательный класс используемый в одном месте.

=back
