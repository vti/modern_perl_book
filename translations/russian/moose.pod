=head1 Moose

Z<moose>

X<moose>

Встроенная в Perl 5 объектная систем гибкая, но совсем минимальная. Вы можете
строить великолепные вещи поверх нее, но она предоставляет скудную помощь для
реализации некоторых основных задач. I<Moose> это полноценная объектая система
для Perl 5N<Смотрите C<perldoc Moose::Manual> для лучшего ознакомления>. Она по
умолчанию предоставляет упрощенные вещи и продвинутые свойства, позаимствованные
из таких языков как Samlltalk, Common Lisp и Perl 6. Код Moose взаимодействует
со встроенной объектной системой и является на сегодняшний день лучшим способом
для написания объектно-ориентированного кода на современном Perl 5.

=head2 Классы

X<classes>
X<builtins; C<package>>

Moose объект это конкретный экземпляр I<класса>, который является шаблоном
описывающим данные и поведение специфичные для объекта. Классы используют пакеты
(L<packages>) для предоставления пространства имен:

=begin programlisting

    package Cat
    {
        use Moose;
    }

=end programlisting

X<OO; instances>

Этот класс C<Cat> I<казалось бы> ничего не делает, но это все, что нужно Moose
для создания класса. Чтобы создать объект (или I<экземпляр>) класса C<Cat>,
воспользуйтесь следующим синтаксисом:

=begin programlisting

    my $brad = Cat->new();
    my $jack = Cat->new();

=end programlisting

Так же как работает разыменование ссылки, так работае и вызов метод на объекте
или классе.

=head2 Методы

X<OO; methods>
X<OO; invocants>

I<Метод> это функция ассоциирующаяся с классам. Также как функции принадлежат
пространству имен, также и методы принадлежат классами, с двумя отличиями.
Во-первых, метод всегда выполняется на I<инвоканте> (I<invocant>). Вызов
C<new()> на C<Cat> посылает классу C<Cat> сообщение. Имя класса C<Cat> это
инвокант C<new()>. Когда вызывается метод на объекте, этот объект является
инвокантом:

=begin programlisting

    my $choco = B<Cat>->new();
    B<$choco>->sleep_on_keyboard();

=end programlisting

X<dispatch>
X<method dispatch>
X<OO; dispatch>
X<OO; method dispatch>

Во-вторых, вызов метода всегда задействует I<диспетчеризацию>, когда объектная
система выбирает подходящий метод. На простом примере C<Cat> диспетчеризации
очевидна, но из этой идеи исходит основная мощь ОО.

Внутри метода первым аргументов является инвокант. Идиоматический Perl
5 в качестве имени инвоканта использует C<$self>. Допустим, C<Cat> может
C<meow()> (I<мяукать> -- прим. перев.):

=begin programlisting

    package Cat
    {
        use Moose;

        B<sub meow>
        B<{>
            B<my $self = shift;>
            B<say 'Meow!';>
        B<}>
    }

=end programlisting

Теперь все экземпляры C<Cat> могут будить вас утром, потому что они еще не ели:

=begin programlisting

    my $fuzzy_alarm = Cat->new();
    $fuzzy_alarm->meow() for 1 .. 3;

=end programlisting

X<class method>
X<instance method>
X<OO; class methods>
X<OO; instance methods>
X<methods; class>
X<methods; instance>

Методы, которые обращаются к данным инвоканта, называются I<методами объекта>,
потому что их правильная работа зависит от корректного инвоканта.  Методы (такие
как C<meow()>), которые не обращаются к данным объекта, называются I<методами
класса>. Вы можете вызывать методы класса на классах, и методы класса и объекта
на объектах, но нельзя вызывать методы объекта на классах.

X<methods; constructor>

I<Конструкторы>, которые I<создают> экземпляры класса, очевидно являются
методами класса. Moose предоставляет вам конструктор по умолчанию.

Методы класса это ограниченные областью видимости глобальные функции. Без
доступа к данным экземпляра класса, у них есть несколько преимуществ перед
другими функциями в той же области видимости.

=head2 Атрибуты

X<attributes; objects>
X<OO; attributes>
X<OO; state>
X<attributes; typed>
X<attributes; C<ro> (read only)>

Каждый объект в Perl 5 уникален. Объекты могут содержать приватные данные
относящиеся к каждому уникальному объекту -- это I<атрибуты>, I<данные
экземпляра класса> или I<состояние> объекта. Для определения атрибута он
объявляется частью класса:

=begin programlisting

    package Cat
    {
        use Moose;

        B<< has 'name', is => 'ro', isa => 'Str'; >>
    }

=end programlisting

На русском это можно прочитать как "У объектов C<Cat> есть атрибут C<name>. Он
доступен только для чления и является строкой."

Moose предоставляет функцию C<has()>, которая объявляет атрибут. Первый
аргумент, C<name> в этом случае, это имя атрибута. Пара аргументов C<< is =>
'ro' >> объявляет этот атрибут доступным только для чтения, т.е. вы его не
сможете изменить после установки значения. И, наконец, пара C<< isa => 'Str' >>
объявляет, что значением этого атрибута может быть только строка.

X<methods; accessor>
X<OO; accessor methods>

В результате вызова C<has> Moose создает I<метод доступа> под названием
C<name()> и разрешает вам передачу параметра C<name> в конструктор C<Cat>:

=begin programlisting

    for my $name (qw( Tuxie Petunia Daisy ))
    {
        my $cat = Cat->new( name => $name );
        say "Created a cat for ", $cat->name();
    }

=end programlisting

=begin sidebar

В документации Moose используются скобки для разделения имени атрибута и его
свойств:

=begin programlisting

        has 'name' => ( is => 'ro', isa => 'Str' );

=end programlisting

Что аналогично:

=begin programlisting

    has( 'name', 'is', 'ro', 'isa', 'Str' );

=end programlisting

Подход Moose хорошо работает и для сложных объявлений:

=begin programlisting

    has 'name' => (
        is         => 'ro',
        isa        => 'Str',

        # advanced Moose options; perldoc Moose
        init_arg   => undef,
        lazy_build => 1,
    );

=end programlisting

... хотя в этой книге отдается преимущество описанию объявления без лишних
знаков пунктуации, используйте тот подход, который для вас является наиболее
читабельным.

=end sidebar

X<attributes; untyped>

Moose не понравится, если вы передадите что-либо не являющееся строкой.
Впрочем, атрибуты не I<обязаны> иметь типы. В этом случае подойдет что угодно:

=begin programlisting

    package Cat
    {
        use Moose;

        has 'name', is => 'ro', isa => 'Str';
        B<< has 'age',  is => 'ro'; >>
    }

    my $invalid = Cat->new( name => 'bizarre',
                            age  => 'purple' );

=end programlisting

Указание типа позволяет Moose выполнять различные проверки данных для вас.
Иногда такая строгость просто неоценима.

X<attributes; C<rw> (read-write)>
X<methods; mutator>
X<OO; mutator methods>

Если вы обозначите атрибут доступным для чтения I<и> записи (с помощью C<< is =>
rw >>), Moose создаст I<модифицирующий метод>, который сможет изменять значение
атрибута:

=begin programlisting

    package Cat
    {
        use Moose;

        has 'name', is => 'ro', isa => 'Str';
        has 'age',  is => 'ro', isa => 'Int';
        B<< has 'diet', is => 'rw'; >>
    }

    my $fat = Cat->new( name => 'Fatty',
                        age  => 8,
                        diet => 'Sea Treats' );

    say $fat->name(), ' eats ', $fat->diet();

    B<< $fat->diet( 'Low Sodium Kitty Lo Mein' ); >>
    say $fat->name(), ' now eats ', $fat->diet();

=end programlisting

Если метод с правами C<ro> вызвать для модификации, он бросит исключение
C<Cannot assign a value to a read-only accessor at ...> (I<Не могу присвоить
значение атрибуту доступному только для чтения ...> -- прим.  перев.).

Использование C<ro> или C<rw> это вопрос дизайна, удобства и чистоты. Moose не
навязывает никакой конкретной философии в этой сфере. Некоторые люди советуют
делать все данные экземпляра класса C<ro>, т.е. при создании объекта обязательно
передавать все данные в конструктор (L<immutability>). На примере C<Cat>,
C<age()> может все еще быть атрибутом, но конструктор может принимать параметр
C<year> в качестве года рождения и вычислять возраст по текущему году.  Этот
подход позволяет консолидировать валидацию и уверенность в том, что все
создаваемые объекты имеют правильные данные.

Данные экземпляра класса демонстрируют суть объекто-ориентированного подхода.
Объект содержит связанные данные и может выполнять различные действия над ними.
Класс описывает эти данные и действия.

=head2 Инкапсуляция

X<encapsulation>
X<OO; encapsulation>

Moose позволяет вам объявлять I<какие> атрибуты принадлежат классу (у кота есть
имя), а также атрибуты этих атрибутов (вы не можете изменить имя кота, только
прочитать его). Moose сам решает как I<хранить> эти атрибуты. Вы можете изменить
это, если хотите, но, позволяя Moose управлять этим хранением, вы поощряете
I<инкапсуляцию>: сокрытие внутренних деталей объекта от внешних пользователей
этого объекта.

Рассмотрим изменение в C<Cat> хранения возраста. Вместо передачи значения
возраста в конструктор, передайте год рождения кота и вычислите его возраст,
когда это необходимо:

=begin programlisting

    package Cat
    {
        use Moose;

        has 'name',        is => 'ro', isa => 'Str';
        has 'diet',        is => 'rw';
        B<< has 'birth_year',  is => 'ro', isa => 'Int'; >>

        B<sub age>
        B<{>
            B<my $self = shift;>
            B<my $year = (localtime)[5] + 1900;>

            B<< return $year - $self->birth_year(); >>
        B<}>
    }

=end programlisting

Несмотря на то, что синтаксис для I<создания> объектов C<Cat> изменился,
синтаксис I<использования> объектов C<Cat> нет. За пределами C<Cat>, C<age>
ведет себя как и раньше. I<Как> он работает внутри уже детали класса C<Cat>.

=begin tip Совместимость и API

Сохраните старый синтаксис для I<создания> объектов C<Cat>, внеся изменения
в конструктор C<Cat> таким образом, чтобы параметр C<age> тоже принимался.
Вычислите значение C<birth_year>. Сверьте с C<perldoc
Moose::Manual::Attributes>.

=end tip

X<attributes; default values>

У вычисления возвраста есть и другое преимущество. I<Значение атрибута по
умолчанию> сработает как нужно, когда кто-то создаст новый объект C<Cat>, передав
туда год рождения:

=begin programlisting

    package Cat
    {
        use Moose;

        has 'name', is => 'ro', isa => 'Str';
        has 'diet', is => 'rw', isa => 'Str';

        B<< has 'birth_year', >>
            B<< is      => 'ro', >>
            B<< isa     => 'Int', >>
            B<< default => sub { (localtime)[5] + 1900 }; >>
    }

=end programlisting

Ключевое слово C<default> у атрибута принимает ссылку на функциюN<Вы можете
использовать простые значения, такие как числа и строки, напрямую, но
используйте ссылку на функцию для всего остального.>, которая возвращает
значения по умолчанию для этого атрибута при создании нового объекта. Если
в коде при создании объекта в конструктор не передается значения этого атрибута,
объекту передастся значение по умолчанию.

=begin programlisting

    my $kitten = Cat->new( name => 'Choco' );

=end programlisting

... и у этого котенка возраст будет C<0> до следующего года.

=head3 Полиморфизм

Инкапсуляция полезна, но действительная мощь объектно-ориентированного подхода
гораздо шире. Хорошо спроектированная ОО программа может управлять многими
типами данных. Когда хорошо спроектированные классы инкапсулируют конкретные
детали объектов в нужных местах, происходит нечто любопытное: код часто
становится I<менее> конкретным.

Перенося детали, которые известны программе об индивидуальных объектах C<Cat>
(атрибутах), и что известно программе о том, что могут делать объекты C<Cat>
(методы), в класс C<Cat> означает, что код, работающий с экземплярами класса
C<Cat>, может вполне обойтись без знаний I<как> C<Cat> это делает.

Рассмотрим функцию, которая выводит детали объекта:

=begin programlisting

    sub show_vital_stats
    {
        my $object = shift;

        say 'My name is ', $object->name();
        say 'I am ',       $object->age();
        say 'I eat ',      $object->diet();
    }

=end programlisting

X<genericity>
X<OO; genericity>

Очевидно (из контекста), что эта функция будет работать, если ей передать объект
C<Cat>. На самом деле, она сработает и для любого объекта с соответствующими
тремя атрибутаи, несмотря на то I<как> этот объект реализует эти методы
и несмотря на то I<каким> этот объект является: C<Cat>, C<Caterpillar> или
C<Catbird>. Эта функция настолько общая, что любой объект реализующий этот
интерфейс будет подходящим параметром.

X<polymorphism>
X<OO; polymorphism>

Это свойство I<полиморфизма> означает, что вы можете заменить объект одного
класса на объект другого класса, если они предоставляют одинаковый внешний
интерфейс.

=begin tip Утиная типизация

X<duck typing>
X<OO; duck typing>

Некоторые языки и среды требуют формальных отношений между двумя классами прежде
чем разрешить программе заменить объекты одного класса на другие. Perl
5 предоставляет возможности для внедрения этих проверок, но не требует их. Его
встроенная специальная система позволяет относится к двум объектам с методами
с одинаковыми именами как к эквивалентам. Некоторые люди называют это I<утиной
типизацией>, рассуждая, что если объект может C<quack()> (I<крякать> -- прим.
перевод.), то он вполне сходит на утку, и к нему можно относится как к утке.

=end tip

C<show_vital_stats()> требует, чтобы вызывающая сущность была корректная
в смысле поддержки трех методов: C<name>, C<age> и C<diet()>, которые не
принимают аргументов и каждый возвращают что-то, что может быть объединено
в строчном контексте. У вас могут быть сотни разных классов в вашем коде, без
каких-либо очевидных связей между ними, но они могут работать с этими методами,
если их поведение соответствует ожидаемому.

Подумайте, как бы вы перечислили животных в зоопарке без этой полиморфной
функции. Преимущество универсальности должно быть очевидным. Так же
и специфичные детали вычисления возраста оцелота или осьминога могут
принадлежать соответствующему классу -- где это лучше всего подходит.

Конечно, только лишь существование метода C<name> или C<age> не подразумевает
того же поведения у объекта. Объект C<Dog> может иметь метод C<age()>,
являющийся методом доступа и позволяющий выяснить, что возраст C<$rodney> 9 лет,
но C<$lucky> -- 4. Объект C<Cheese> может иметь метод C<age()>, который
позволяет вам контролировать насколько долго хранить C<$cheddar> для придания
ему остроты. C<age()> может быть методом доступа в одном классе, но не в другом:

=begin programlisting

    # сколько лет коту
    my $years = $zeppie->age();

    # оставить сыр на складе на шесть месяцев
    $cheese->age();

=end programlisting

Иногда полезно узнать I<что> объект делает и что это I<означает>.

=head2 Роли

Z<roles>
X<roles>

I<Роль> это именованное объединение поведения и состоянияN<Посмотрите
документацию как организованы роли в Perl 6 на
U<http://feather.perl6.nl/syn/S14.html>, для более подробного описания
ознакомьтесь с типажами в Smalltalk U<http://scg.unibe.ch/research/traits>.>.
В то время как класс организовывает поведение и состояние в виде шаблона для
объектов, роль организовывает именованное объединение поведения и состояния. Вы
можете создать экземпляр класса, но не роли. Роль это что-то, что класс делает.

Например, у класса C<Animal> есть метод C<age()>, который означает возвраст,
а C<Chesse> есть такой же метод C<age()>, но который состаривает его, различием
может быть то, что C<Animal> реализует роль C<LivingBeing>, в то время как
C<Chesse> -- C<Storable>:

=begin programlisting

    package LivingBeing
    {
        use Moose::Role;

        requires qw( name age diet );
    }

=end programlisting

Все, что реализует эту роль, должно предоставлять методы C<name()>, C<age()>
и C<diet()>. Класс C<Cat> должен явно указать, что реализует роль:

=begin programlisting

    package Cat
    {
        use Moose;

        has 'name', is => 'ro', isa => 'Str';
        has 'diet', is => 'rw', isa => 'Str';

        has 'birth_year',
            is      => 'ro',
            isa     => 'Int',
            default => sub { (localtime)[5] + 1900 };

        B<with 'LivingBeing';>

        sub age { ... }
    }

=end programlisting

X<roles; composition>

Ключевое слово C<with> говорит Moose I<скомпоновать> роль C<LivingBeing>
c классом C<Cat>. Композиция здесь гарантирует, что все атрибуты и методы роли
являются частью класса. C<LivingBeing> требует у класса реализации методов
C<name()>, C<age()> и C<diet()>. C<Cat> удовляетворяет этим требованиям. Если бы
C<LivingBeing> компоновалось с классом не предоставлявшим эти методы, Moose
бросило бы исключение.

=begin tip Порядок важен!

Ключевое слово C<with>, применяющее роли к классу, должно быть указано I<после>
декларации атрибутов, чтобы во время композиции можно было правильно определить
все методы.

=end tip

Теперь все объекты C<Cat> при вызове метода, определяющего предоставляют ли они
роль C<LivingBeing>, будут возвращать истинное значение. Объекты C<Cheese> же
нет:

=begin programlisting

    say 'Alive!' if $fluffy->DOES('LivingBeing');
    say 'Moldy!' if $cheese->DOES('LivingBeing');

=end programlisting

Эта техника проектирования отделяет I<возможности> классов и объектов от
I<реализации> этих классов и объектов. Поведение вычисления года рождения
классса C<Cat> может само быть ролью:

=begin programlisting

    package CalculateAge::From::BirthYear
    {
        use Moose::Role;

        has 'birth_year',
            is      => 'ro',
            isa     => 'Int',
            default => sub { (localtime)[5] + 1900 };

        sub age
        {
            my $self = shift;
            my $year = (localtime)[5] + 1900;

            return $year - $self->birth_year();
        }
    }

=end programlisting

Выделение роли из C<Cat> делает это поведение доступным и для других классов.
Теперь C<Cat> может компоноваться с обеими ролями:

=begin programlisting

    package Cat
    {
        use Moose;

        has 'name', is => 'ro', isa => 'Str';
        has 'diet', is => 'rw';

        B<with 'LivingBeing',>
             B<'CalculateAge::From::BirthYear';>
    }

=end programlisting

Обратите внимание, что метод C<age> роли C<CalculateAge::From::BirthYear>
удовлетворяет требованию роли C<LivingBeing>. Также обратите внимание, что любая
проверка C<Cat> на соответствие роли C<LivingBeing> возвращает истинное
значение. Выделение C<age()> в роль изменило только реализацию I<как> C<Cat>
вычисляет возраст. Класс C<Cat> может решить реализовать свой собственный метод
вычисления возраста или вообще брать его откуда-то еще. Имеет значение только
то, что он реализовывает C<age()> и удовлетворяет требованиям C<LivingBeing>.

X<allomorphism>
X<roles; allomorphism>

Также как полиморфизм означает то, что со многими объектами с одинаковым
поведением можно работать одинаково, так и этот I<алломорфизм> означает то, что
объект может реализовывать одинаковое поведение разными способами.

Повсеместный алломорфизм может уменьшить размеры ваших классов и увеличить
коллективно используемый код. Он также позволяет давать имена специфичным
и отдельным коллекциям со своим поведением -- что эффективно для проверки
возможностей объектов вместо проверки их реализаций.

X<OO; mixins>
X<OO; multiple inheritance>
X<OO; monkeypatching>

Для сравнений ролей с другими техниками проектирования такими как mixins,
множественным наследованием и monkeypatching, посмотрите на
U<http://www.modernperlbooks.com/mt/2009/04/the-why-of-perl-roles.html>.

=head3 Роли и DOES()

X<C<DOES()>>
X<Moose; C<DOES()>>

Когда вы компонуете роль в класс, класс и его экземпляры при вызове метода
C<DOES()> будут возвращать истинное значение:

=begin programlisting

    say 'This Cat is alive!'
        if $kitten->DOES( 'LivingBeing' );

=end programlisting

=head2 Наследование

Z<inheritance>

X<inheritance>
X<OO; inheritance>
X<Moose; inheritance>

Объектная система Perl 5 поддерживает I<наследование>, которое устанавливает
связь между двумя классами таким образом, что один детализирует другой. Дочерний
класс ведет себя также как и родительский -- у него такое же количество и такие
же типы атрибутов, а также могут быть одинаковые методы. У него могут быть
дополнительные данные и поведение, но вы можете заменить любой экземпляр
дочернего класса везде где используется родительский. В некотором смысле
подкласс реализовывает роль неявно предоставляемой родительским классом.

=begin tip Роли против наследования

Стоит ли вам использовать роли или наследование? Роли предоставляют безопасную
композицию, лучшую проверку типов, лучшую организацию куда и более тонкий
контроль над именами и поведением, в то время как наследование хорошо знакомо
опытным разработчикам на других языках. Используйте наследование когда один
класс действительно I<расширяет> другой. Используйте роль когда классу нужно
дополнительное поведение, и когда вы можете этому поведению дать значимое имя.

=end tip

Возьмем класс C<LightSource>, который предоставляет два публичных атрибута
(C<enabled> и C<candle_power>) и два метода (C<light> и C<extinguish>):

=begin programlisting

    package LightSource
    {
        use Moose;

        has 'candle_power', is      => 'ro',
                            isa     => 'Int',
                            default => 1;

        has 'enabled', is      => 'ro',
                       isa     => 'Bool',
                       default => 0,
                       writer  => '_set_enabled';

        sub light
        {
            my $self = shift;
            $self->_set_enabled(1);
        }

        sub extinguish
        {
            my $self = shift;
            $self->_set_enabled(0);
        }
    }

=end programlisting

(Заметьте, что опция C<writer> у C<enabled> создает приватный метод доступа,
используемый внутри класса для установки значения.)

=head3 Наследование и атрибуты

Подкласс класса C<LightSource> может определить метод супер свеча, который
предоставляет в сто раз большее количество света:

=begin programlisting

    package SuperCandle
    {
        use Moose;

        B<extends 'LightSource'>;

        has 'B<+>candle_power', default => 100;
    }

=end programlisting

X<Moose; C<extends>>

C<extends> берет список имен классов, которые используются как родители текущего
класса. Если была бы только эта строчка, объекты класса C<SuperCandle> вели себя
точно так же как и объекты класса C<LightSource>. У них у обоих были бы атрибуты
C<candle_power> и C<enabled>, также как и методы C<light()> и C<extinguish()>.

C<+> в начале имени атрибута (как у C<candle_power>) означает, что текущий класс
делает что-то специальное с этим атрибутом. В данном случае супер свеча
переопределяет атрибут по умолчанию, так что каждый новый объект C<SuperCandle>
будет иметь величину света в 100 свечей.

Когда вы вызываете C<light()> или C<extinguish()> на объекте C<SuperCandle>,
Perl будет искать метод вначале в классе C<SuperCandle>, а затем в каждом
родительском классе. В данном случае, это методы в классе C<LightSource>.

X<Moose; attribute inheritance>

Наследование атрибутов работает похожим образом (посмотрите C<perldoc
Class::MOP>).

=head3 Порядок назначения методов

X<methods; resolution>
X<method resolution order>
X<methods; dispatch order>
X<multiple inheritance>
X<objects; inheritance>
X<objects; multiple inheritance>
X<MRO>

I<Порядок назначения методов> (или I<порядок разрешения методов> или I<MRO>)
очевидно для классов с одним родителем. Нужно посмотреть в классе объекта, затем
у его родителей и так далее пока метод не будет найден или же не закончатся
родители. Классы, которые наследуют несколько родителей (I<множественное
наследование>) -- например, класс С<Hovercraft> может расширять оба класса
C<Boat> и C<Car>) -- требуют более сложного механизма. Рассуждения вокруг
множественного расследования довольно сложны. Избегайте множетсвенного
наследования когда возможно.

Perl 5 для решения данной проблемы использует метод поиска в глубину. Он ищет
рекурсивно в классе указанным I<первым> в списке и в его родителях, прежде чем
перейти к другим родительским классам. Прагма C<mro> (L<pragmas>) предоставляет
альтернативный способ, включая способ C3 MRO, который ищет вначале в прямых
родителях текущего класса, прежде чем перейти к родителям родителей.

Посмотрите C<perldoc mro>, чтобы ознакомиться с деталями.

=head3 Наследование и методы

X<Moose; overriding methods>
X<Moose; C<override>>

Также как и с атрибутами, подклассы могут переопределять методы. Представьте
себе свет, который нельзя зажечь:

=begin programlisting

    package Glowstick
    {
        use Moose;

        extends 'LightSource';

        sub extinguish {}
    }

=end programlisting

Метод C<extinguish()> вызванный на объекте светящейся палочки, ничего не делает,
даже если метод класса C<LightSource> что-то делает. При поиске метода будет
найден метод подкласса. Возможно, вы этого не хотели. Если же это и было нужно,
используйте C<override> из Moose для явного указания переопределения метода.

Внутри переопределенного метода, C<super()> из Moose позволяет вызвать
переопределенный метод:

=begin programlisting

    package LightSource::Cranky
    {
        use Carp 'carp';
        use Moose;

        extends 'LightSource';

        B<override> light => sub
        {
            my $self = shift;

            carp "Can't light a lit light source!"
                if $self->enabled;

            B<super()>;
        };

        B<override> extinguish => sub
        {
            my $self = shift;

            carp "Can't extinguish unlit light source!"
                unless $self->enabled;

            B<super()>;
        };
    }

=end programlisting

Подкласс выдаст предупреждение при попытке включить или зажечь источник света,
который уже находится в этом состоянии. Фунция C<super()> вызовет метод
реализованный в ближайшем родительском классе, как и при обычном разрешении
методов в Perl 5.

=begin tip На базе Moose

Модификаторы методов в Moose могут делать подобные вещи -- и даже больше.
Посмотрите на C<perldoc Moose::Manual::MethodModifiers>.

=end tip

=head3 Наследование и isa()

X<C<isa()>>
X<Moose; C<isa()>>

Метод C<isa()> в Perl возвращает истинное значение если инвокантом является или
расширяет указанный класс. Инвокант может быть и именем класса и экземпляром
объекта.

=begin programlisting

    say 'Looks like a LightSource'
        if $sconce->isa( 'LightSource' );

    say 'Hominidae do not glow'
        unless $chimpy->isa( 'LightSource' );

=end programlisting

=head2 Moose и объектная система Perl 5

X<Moose; compared to default Perl 5 OO>

Moose предоставляет множество полезный свойств в дополнение к стандартной
объектной системе Perl 5. Конечно, вы I<можете> написать все, что предоставляет
Moose самостоятельно (L<blessed_references>), или накидать в кучу несколько
дистрибутивов с CPAN, но все-таки Moose стоит использовать. Модуль
последовательный и с хорошей документацией. Многие важные проекты испешно
используют Moose. Сообщество разработчиков достаточно зрелое и внимательное.

X<metaprogramming>
X<Moose; MOP>
X<Moose; metaprogramming>
X<C<Class::MOP>>
X<C<Class::MOP::Class>>

Moose берет на себя конструкторы, деструкторы, методы доступа и инкапсуляцию.
Вам, конечно, придется объявлять желаемые структуры, но получаемые механизмы
безопасны и просто используются. Moose-объекты могут расширять и работать
с другими объектами из стандартной модели Perl 5.

Moose также разрешает I<метапрограммирование> -- управление объектами через сам
же Moose. Если вам когда-либо хотелось узнать какие методы доступны в классе или
объекте, или какие атрибуты объект поддерживает, эта информация становится
доступной:

=begin programlisting

    my $metaclass = Monkey::Pants->meta();

    say 'У экземпляров Monkey::Pants такие атрибуты:';

    say $_->name for $metaclass->get_all_attributes;

    say 'Экземпляры Monkey::Pants поддерживают такие методы:';

    say $_->fully_qualified_name
        for $metaclass->get_all_methods;

=end programlisting

Можно также увидеть какие класса расширяют текущий класс:

=begin programlisting

    my $metaclass = Monkey->meta();

    say 'Monkey это суперкласс над:';

    say $_ for $metaclass->subclasses;

=end programlisting

Посмотрите C<perldoc Class::MOP::Class> для подробной информации об операциях
метакласса и C<perldoc Class::MOP> для информации о метапрограммировании
в Moose.

Moose и его I<мета-объектный протокол> (или MOP) предоставляет возможности
улучшеннего синтаксиса для объявления и работы с классами и объектами в Perl 5.
Вот, например, работающий код на Perl 5:

=begin programlisting

    use MooseX::Declare;

    B<role> LivingBeing { requires qw( name age diet ) }

    B<role> CalculateAge::From::BirthYear
    {
        has 'birth_year',
            is      => 'ro',
            isa     => 'Int',
            default => sub { (localtime)[5] + 1900 };

        B<method> age
        {
            return (localtime)[5] + 1900
                                  - $self->birth_year();
        }
    }

    B<class Cat with LivingBeing>
              B<with CalculateAge::From::BirthYear>
    {
        has 'name', is => 'ro', isa => 'Str';
        has 'diet', is => 'rw';
    }

=end programlisting

X<CPAN; C<MooseX::Declare>>
X<CPAN; C<Devel::Declare>>

CPAN дистрибутив C<MooseX::Declare> использует C<Devel::Declar> для добавления
специфичного для Moose синтаксиса. Ключевые слова C<class>, C<role> и C<method>
уменьшают количество рутинного шаблонного кода необходимого для написания
хорошего объектно-ориентированного кода в Perl 5. Обратите внимание на
декларативный стиль примера выше, а также на отсутствие C<my $self = shift;>
в методе C<age()>.

Хотя Moose и не является частью ядра Perl 5, его популярность гарантирует
доступность во многих дистрибутивах операционных систем. Такие дистрибутивы как
Strawberry Perl и ActivePerl также включают его. Несмотря на то, что Moose это
CPAN модуль, а не стандартная библиотека, его чистота и простота делают его
неотъемлимой частью программирования на современном Perl.

=begin tip The Svelte I<Alces>

X<CPAN; C<Any::Moose>>

Moose это не маленькая библиотека, но она очень мощная. CPAN модуль
C<Any::Moose> позволяет использовать более легковесную библиотеку, если вам не
нужны какие-то функции (I<на данный момент рекомендуется использовать Moo> --
прим. перев.).

=end tip
